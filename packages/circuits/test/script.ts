import * as crypto from "crypto";
import pako from "pako";
import fs from "fs";

function convertBase10ToBigInt(value: string): bigint {
  return BigInt(value);
}

function convertBigIntToByteArray(bigInt: bigint) {
  let byteLength = Math.max(1, Math.ceil(bigInt.toString(2).length / 8));

  let result = new Uint8Array(byteLength);
  let i = 0;
  while (bigInt > 0) {
    result[i] = Number(bigInt % BigInt(256));
    bigInt = bigInt / BigInt(256);
    i += 1;
  }
  return result.reverse();
}

function decompressByteArray(byteArray: Uint8Array) {
  let decompressedArray = pako.inflate(byteArray);
  return decompressedArray;
}

function findDelimiter(byteArray: Uint8Array, startIndex: number) {
  let delimiterIndex = byteArray.indexOf(255, startIndex);
  return delimiterIndex;
}

function readAndConvertToString(
  byteArray: Uint8Array,
  startIndex: number,
  endIndex: number
) {
  let stringBytes = byteArray.slice(startIndex, endIndex);
  let decoder = new TextDecoder("ISO-8859-1");
  let stringValue = decoder.decode(stringBytes);
  return stringValue;
}

function readSignature(byteArray: Uint8Array) {
  let signatureStartIndex = byteArray.length - 256;
  let signature = byteArray.slice(signatureStartIndex, byteArray.length);
  return signature;
}

const extract = (n: string) => {
  const bigIntData = convertBase10ToBigInt(n);

  const byteArray = convertBigIntToByteArray(bigIntData);
  console.log("Array of bytes: ", byteArray);

  const decompressedByteArray = decompressByteArray(byteArray);
  console.log(decompressedByteArray);

  let dilimiter = findDelimiter(decompressedByteArray, 0);
  console.log(dilimiter);

  const Email_mobile_present_bit_indicator: Record<number, string> = {
    0: "Not Email/Mobile",
    1: "Only Email",
    2: "Only Mobile",
    3: "Both email/Mobile",
  };

  const isMobileOrEmailAvailable = readAndConvertToString(
    decompressedByteArray,
    0,
    dilimiter
  );

  console.log(
    "Is mobile or email?: ",
    Email_mobile_present_bit_indicator[Number(isMobileOrEmailAvailable)]
  );

  const value: string[] = [];
  const userDetails = {
    referenceId: "",
    name: "",
    dob: "",
    gender: "",
    careof: "",
    address: {
      district: "",
      landmark: "",
      house: "",
      location: "",
      pincode: "",
      postoffice: "",
      State: "",
      Street: "",
      Subdistrict: "",
      VTC: "",
    },
  };

  for (let i = 0; i < 15; i++) {
    // dilimiter = dilimiter + 1
    const nextDilimeter = findDelimiter(decompressedByteArray, dilimiter + 1);
    console.log("nextDilimeter", dilimiter);

    const referenceId: string = readAndConvertToString(
      decompressedByteArray,
      dilimiter + 1,
      nextDilimeter
    );
    value.push(referenceId);
    dilimiter = nextDilimeter;
    console.log(i, "referenceId", referenceId);
  }
};

const verifySignature = (n: string) => {
  const bigIntData = convertBase10ToBigInt(n);

  const byteArray = convertBigIntToByteArray(bigIntData);

  const decompressedByteArray = decompressByteArray(byteArray);

  // Read signature data
  const signature = readSignature(decompressedByteArray);
  //   console.log("signature", signature);
  //   console.log("signature", Buffer.from(signature).toString("base64"));
  //   console.log("signature", signature.length);

  const certData = fs.readFileSync("./uidai_offline_publickey_26022021.cer");

  const pk = crypto.createPublicKey(certData);

  const signedData = decompressedByteArray.slice(0, -256);

  const isSignatureValid = crypto.verify(
    "sha256WithRSAEncryption",
    signedData,
    pk,
    signature
  );

  console.log(isSignatureValid);
};

// Input n should be base10 bigint string
const ntest =
  "6979414848205548481619299442879901900893978332594614407044767717485407280104077714658698163325401659212830920734233047578454701810567032015270223682917915825234703754712504887921309181789607809168884583848396456653007022479356336240198130363930881632367124738541517499494458139647378808680614169273221404741476596583953169248831376224396335169577064812987140578144885819479190173537644970232125142253963784979138011318798385442436099901621998283624816070080504830712594525760596934341576755626791590403636878139861665599383319429228364434183913197958738697001410493839281298692342829951566712530309758759364649701153639921979798429707566199261950037418171329283207372048014948669160666776198414040633384677104717697507521717586776709084200364956178863636105988867260929887577092955570407803783021397897341999914616790441029837229129746669225095633201097644321593502503404440714110515167034889128258965583435965030225845348564582051521348800742574442877087774194668983516629631073341202705453382780613775427336949283388084891654484225446940941660942440637784744293259916479841407088189462964489670231866481904237338494872813098890875845640034370370387108798950180220865436012752487216677041817312930119747601017807577565413977545693375480131324240696099879479436722576566447939593195590684591261809038023122178172006150499569185218838749337238281597037288924464009997530938336798176023597292328320965086990184531426188862965408313308973495924965144113396593829090645266653313774582036138982013368561474719154447134894466611560589758251829063226370300282175823479569847261439348404558251402273730865053482214589180028302043821438357583302818374143973997002745047526405755760407045006694423501337081780299815080324840337828812644300041900356816429114261098230198976752026002079876882796597235615015594486182057781476152918170746403157005216896239428521706033466061587608065036133153074432195952131368564234168005447770190345777024917629879639171161719929852078265309160759260989590618158889891835294735614366674503961584445497685736312628248483551986529867423016255476553691922054241686230968975229511700928171281549902682365302333677412951788839806869796040512235899311734337858684531156721416280114473368826463098485252394260075790386415875290922570568686439586036262465414002334117870088922801660529414759784318799843806130096998190881240404138869293309782335305296720666220243304175086358278211355789957998014801209332293458940463859106591986434520433810583569309224929264228263841477378949329312443958215939294432669464260216534074560882723006838459792812340253078330291135526952675203790833430237852831740601433198364243363569730205351077393441691141240055900819091229931605146865520183001810239708464322588389956036291760175558843819105418234580239610174323636606095262722940143706063698846499673285377621180570537788160304936809915237889489342387891057012783726694920184573202789672963922380028271124448024265644396686341508447830351380242127542393849410283830409594988503246799544444687606954881510597515686410993828907588979699141180160893062603338104857903239845856783130275935413569275439908789983311663211937449259444259898972766208";
// const n = "";
// verifySignature(n);

extract(ntest);

